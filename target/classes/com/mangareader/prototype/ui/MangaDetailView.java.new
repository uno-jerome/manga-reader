package com.mangareader.prototype.ui;

import com.mangareader.prototype.model.Manga;
import com.mangareader.prototype.model.Chapter;
import com.mangareader.prototype.service.MangaService;
import com.mangareader.prototype.service.impl.DefaultMangaServiceImpl;
import javafx.application.Platform;
import javafx.beans.property.SimpleObjectProperty;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.collections.transformation.FilteredList;
import javafx.collections.transformation.SortedList;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.control.*;
import javafx.scene.layout.*;
import javafx.scene.image.ImageView;
import javafx.scene.image.Image;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Rectangle;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javafx.scene.text.Text;
import javafx.scene.text.TextAlignment;

import java.time.format.DateTimeFormatter;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public class MangaDetailView extends BorderPane {
    // UI Components
    private final ImageView coverImageView;
    private final Label titleLabel;
    private final Label authorLabel;
    private final Label artistLabel;
    private final Label statusLabel;
    private final Label languageLabel;
    private final Label lastUpdatedLabel;
    private final TextArea descriptionArea;
    private final FlowPane genresPane;
    private final Button readButton;
    private final Button downloadButton;
    private final Button addToLibraryButton;
    private final Button refreshButton;
    private final TableView<Chapter> chaptersTable;
    private final TabPane chaptersTabPane;
    private final TextField chapterSearchField;
    private final ComboBox<String> sortComboBox;
    private final ComboBox<String> filterComboBox;
    private final Pagination chapterPagination;
    private final Label totalChaptersLabel;
    private final ProgressBar readProgressBar;
    private final Label readProgressLabel;

    // Stats display
    private final GridPane statsGrid;
    private final Map<String, Label> statsLabels = new HashMap<>();

    // Data
    private final MangaService mangaService;
    private final Consumer<Chapter> onChapterSelectedCallback;
    private Manga currentManga;
    private final ObservableList<Chapter> chapters = FXCollections.observableArrayList();
    private final FilteredList<Chapter> filteredChapters = new FilteredList<>(chapters, p -> true);
    private final SortedList<Chapter> sortedChapters = new SortedList<>(filteredChapters);
    private final int CHAPTERS_PER_PAGE = 50;
    private int currentChapterPage = 0;

    public MangaDetailView() {
        this(null);
    }

    public MangaDetailView(Consumer<Chapter> onChapterSelectedCallback) {
        this.onChapterSelectedCallback = onChapterSelectedCallback;
        this.mangaService = new DefaultMangaServiceImpl();
        
        setPadding(new Insets(20));
        setStyle("-fx-background-color: #f9f9f9;");
        
        // Cover Image
        coverImageView = new ImageView();
        coverImageView.setFitWidth(250);
        coverImageView.setFitHeight(350);
        coverImageView.setPreserveRatio(true);
        
        // Create a clip for the ImageView to have rounded corners
        Rectangle clip = new Rectangle(250, 350);
        clip.setArcWidth(20);
        clip.setArcHeight(20);
        coverImageView.setClip(clip);
        
        coverImageView.setStyle(
                "-fx-effect: dropshadow(gaussian, rgba(0,0,0,0.25), 10, 0, 0, 4);");
        
        // Set a placeholder image
        String placeholderUrl = "https://via.placeholder.com/250x350/f8f9fa/6c757d?text=No+Cover";
        coverImageView.setImage(new Image(placeholderUrl, true));

        // Enhanced Labels with styling
        titleLabel = new Label();
        titleLabel.setStyle("-fx-font-size: 28px; -fx-font-weight: bold; -fx-wrap-text: true;");
        titleLabel.setWrapText(true);
        titleLabel.setMaxWidth(700);
        
        authorLabel = new Label();
        authorLabel.setStyle("-fx-font-size: 16px; -fx-font-weight: bold;");
        
        artistLabel = new Label();
        artistLabel.setStyle("-fx-font-size: 16px; -fx-font-weight: bold;");
        
        statusLabel = new Label();
        statusLabel.setStyle("-fx-font-size: 14px; -fx-padding: 5 10; -fx-background-radius: 15; -fx-background-color: #e7f3ff; -fx-text-fill: #0066cc;");
        
        languageLabel = new Label();
        languageLabel.setStyle("-fx-font-size: 14px; -fx-padding: 5 10; -fx-background-radius: 15; -fx-background-color: #e7f3ff; -fx-text-fill: #0066cc;");
        
        lastUpdatedLabel = new Label();
        lastUpdatedLabel.setStyle("-fx-font-size: 14px; -fx-text-fill: #666;");
        
        // Description Area with better styling
        descriptionArea = new TextArea();
        descriptionArea.setEditable(false);
        descriptionArea.setWrapText(true);
        descriptionArea.setPrefRowCount(8);
        descriptionArea.setStyle(
            "-fx-control-inner-background: #f8f9fa; " +
            "-fx-background-color: #f8f9fa; " +
            "-fx-border-color: #dee2e6; " +
            "-fx-border-radius: 5; " +
            "-fx-background-radius: 5; " +
            "-fx-focus-color: transparent; " +
            "-fx-faint-focus-color: transparent;"
        );
        
        // Genres Pane with improved styling
        genresPane = new FlowPane();
        genresPane.setHgap(8);
        genresPane.setVgap(8);
        genresPane.setPrefWrapLength(600);
        genresPane.setPadding(new Insets(10, 0, 10, 0));
        
        // Statistics Grid
        statsGrid = new GridPane();
        statsGrid.setHgap(15);
        statsGrid.setVgap(10);
        statsGrid.setPadding(new Insets(15));
        statsGrid.setStyle(
            "-fx-background-color: #f0f0f0; " +
            "-fx-border-color: #dee2e6; " +
            "-fx-border-radius: 5; " +
            "-fx-background-radius: 5;"
        );
        
        // Initialize stats labels
        String[] statsKeys = {"Rating", "Users", "Follows", "Popularity", "Release Year", "Chapter Count"};
        for (int i = 0; i < statsKeys.length; i++) {
            Label keyLabel = new Label(statsKeys[i] + ":");
            keyLabel.setStyle("-fx-font-weight: bold;");
            Label valueLabel = new Label("--");
            valueLabel.setStyle("-fx-font-size: 14px;");
            
            statsLabels.put(statsKeys[i], valueLabel);
            statsGrid.add(keyLabel, 0, i);
            statsGrid.add(valueLabel, 1, i);
        }
        
        // Read progress
        readProgressBar = new ProgressBar(0);
        readProgressBar.setPrefWidth(200);
        readProgressBar.setStyle("-fx-accent: #28a745;");
        
        readProgressLabel = new Label("0 / 0 chapters read");
        readProgressLabel.setStyle("-fx-font-size: 14px;");
        
        VBox progressBox = new VBox(5, new Label("Reading Progress"), readProgressBar, readProgressLabel);
        progressBox.setPadding(new Insets(15, 0, 15, 0));
        
        // Enhanced Buttons with icons
        readButton = new Button("Start Reading");
        readButton.setStyle(
            "-fx-font-size: 14px; " +
            "-fx-background-color: #007bff; " +
            "-fx-text-fill: white; " +
            "-fx-padding: 10 20; " +
            "-fx-background-radius: 5;"
        );
        readButton.setPrefWidth(150);
        
        downloadButton = new Button("Download");
        downloadButton.setStyle(
            "-fx-font-size: 14px; " +
            "-fx-background-color: #28a745; " +
            "-fx-text-fill: white; " +
            "-fx-padding: 10 20; " +
            "-fx-background-radius: 5;"
        );
        downloadButton.setPrefWidth(150);
        
        addToLibraryButton = new Button("Add to Library");
        addToLibraryButton.setStyle(
            "-fx-font-size: 14px; " +
            "-fx-background-color: #6c757d; " +
            "-fx-text-fill: white; " +
            "-fx-padding: 10 20; " +
            "-fx-background-radius: 5;"
        );
        addToLibraryButton.setPrefWidth(150);
        
        refreshButton = new Button("Refresh");
        refreshButton.setStyle(
            "-fx-font-size: 14px; " +
            "-fx-background-color: #17a2b8; " +
            "-fx-text-fill: white; " +
            "-fx-padding: 10 20; " +
            "-fx-background-radius: 5;"
        );
        refreshButton.setPrefWidth(150);
        
        // Buttons layout
        HBox buttonBox = new HBox(10, readButton, downloadButton);
        HBox secondaryButtonBox = new HBox(10, addToLibraryButton, refreshButton);
        
        VBox buttonLayout = new VBox(10, buttonBox, secondaryButtonBox);
        buttonLayout.setAlignment(Pos.CENTER_LEFT);
        buttonLayout.setPadding(new Insets(15, 0, 15, 0));
        
        // Chapter List Table
        chaptersTable = new TableView<>();
        chaptersTable.getStyleClass().add("chapter-table");
        chaptersTable.setMinHeight(400);
        
        // Search and Filter Box
        chapterSearchField = new TextField();
        chapterSearchField.setPromptText("Search chapters...");
        chapterSearchField.textProperty().addListener((obs, oldVal, newVal) -> {
            filterChapters(newVal);
        });
        
        // Sorting dropdown
        sortComboBox = new ComboBox<>();
        sortComboBox.getItems().addAll("Newest First", "Oldest First", "By Volume");
        sortComboBox.setValue("Newest First");
        sortComboBox.getStyleClass().add("combo-box-elegant");
        sortComboBox.valueProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal != null) {
                sortChapters(newVal);
            }
        });
        
        // Volume filter
        filterComboBox = new ComboBox<>();
        filterComboBox.setPromptText("Filter by Volume");
        filterComboBox.getItems().addAll("All");
        filterComboBox.setValue("All");
        filterComboBox.getStyleClass().add("combo-box-elegant");
        filterComboBox.valueProperty().addListener((obs, oldVal, newVal) -> {
            if (newVal != null) {
                filterChaptersByVolume(newVal);
            }
        });
        
        HBox searchBox = new HBox(10, 
            new Label("Search:"), chapterSearchField,
            new Separator(javafx.geometry.Orientation.VERTICAL),
            new Label("Sort:"), sortComboBox,
            new Separator(javafx.geometry.Orientation.VERTICAL),
            new Label("Volume:"), filterComboBox
        );
        searchBox.setAlignment(Pos.CENTER_LEFT);
        searchBox.setPadding(new Insets(0, 0, 10, 0));
        
        // Chapter count and pagination
        totalChaptersLabel = new Label("Total: 0 chapters");
        totalChaptersLabel.setStyle("-fx-font-size: 14px;");
        
        chapterPagination = new Pagination(1, 0);
        chapterPagination.getStyleClass().add("simple-pagination");
        chapterPagination.currentPageIndexProperty().addListener((obs, oldVal, newVal) -> {
            currentChapterPage = newVal.intValue();
            updateChapterTable();
        });
        
        HBox paginationBox = new HBox(10, totalChaptersLabel, chapterPagination);
        paginationBox.setAlignment(Pos.CENTER_LEFT);
        
        // Set up chapters table
        TableColumn<Chapter, String> chapterColumn = new TableColumn<>("Chapter");
        chapterColumn.setPrefWidth(70);
        chapterColumn.setCellValueFactory(data -> {
            Chapter chapter = data.getValue();
            return new SimpleObjectProperty<>("Ch. " + chapter.getNumber());
        });
        
        TableColumn<Chapter, String> titleColumn = new TableColumn<>("Title");
        titleColumn.setPrefWidth(400);
        titleColumn.setCellValueFactory(data -> new SimpleObjectProperty<>(data.getValue().getTitle()));
        
        TableColumn<Chapter, String> volumeColumn = new TableColumn<>("Volume");
        volumeColumn.setPrefWidth(70);
        volumeColumn.setCellValueFactory(data -> {
            Chapter chapter = data.getValue();
            return new SimpleObjectProperty<>(chapter.getVolume() != null ? "Vol. " + chapter.getVolume() : "");
        });
        
        TableColumn<Chapter, String> dateColumn = new TableColumn<>("Date");
        dateColumn.setPrefWidth(100);
        dateColumn.setCellValueFactory(data -> {
            Chapter chapter = data.getValue();
            return new SimpleObjectProperty<>(chapter.getPublishedDate() != null ? 
                    chapter.getPublishedDate().format(DateTimeFormatter.ofPattern("yyyy-MM-dd")) : "");
        });
        
        TableColumn<Chapter, String> statusColumn = new TableColumn<>("Status");
        statusColumn.setPrefWidth(100);
        statusColumn.setCellValueFactory(data -> {
            return new SimpleObjectProperty<>("Unread");
        });
        
        chaptersTable.getColumns().addAll(chapterColumn, titleColumn, volumeColumn, dateColumn, statusColumn);
        chaptersTable.setItems(sortedChapters);
        
        // Row click handler
        chaptersTable.setRowFactory(tv -> {
            TableRow<Chapter> row = new TableRow<Chapter>() {
                @Override
                protected void updateItem(Chapter item, boolean empty) {
                    super.updateItem(item, empty);

                    if (item == null || empty) {
                        setStyle("");
                        return;
                    }

                    // Style based on read status (placeholder for actual read status)
                    boolean isRead = false;
                    if (isRead) {
                        setStyle("-fx-background-color: #f8f9fa;");
                    } else {
                        setStyle("");
                    }
                }
            };
            
            row.setOnMouseClicked(event -> {
                if (event.getClickCount() == 2 && !row.isEmpty()) {
                    Chapter chapter = row.getItem();
                    if (onChapterSelectedCallback != null) {
                        onChapterSelectedCallback.accept(chapter);
                    }
                }
            });
            
            return row;
        });
        
        // Tab pane for different chapter views (list, grid, volume)
        chaptersTabPane = new TabPane();
        
        Tab listTab = new Tab("List",
            new BorderPane(chaptersTable, null, null, chapterPagination, null));
        listTab.setClosable(false);

        Tab gridTab = new Tab("Grid", new ScrollPane(createChapterGrid()));
        gridTab.setClosable(false);

        Tab volumeTab = new Tab("Volumes", createVolumeView());
        volumeTab.setClosable(false);

        chaptersTabPane.getTabs().addAll(listTab, gridTab, volumeTab);
        chaptersTabPane.getStyleClass().add("floating-tab-pane");

        // Main Layout with better organization
        VBox topInfoLayout = new VBox(10);

        VBox titleAuthorBox = new VBox(5);
        titleAuthorBox.getChildren().addAll(titleLabel, new HBox(10, authorLabel, artistLabel));
        
        HBox statusBox = new HBox(10, statusLabel, languageLabel, lastUpdatedLabel);
        statusBox.setAlignment(Pos.CENTER_LEFT);
        
        topInfoLayout.getChildren().addAll(titleAuthorBox, statusBox, genresPane);
        
        HBox infoGridLayout = new HBox(20);
        infoGridLayout.setPadding(new Insets(10, 0, 10, 0));
        
        VBox detailsBox = new VBox(15, 
            descriptionArea, 
            buttonLayout,
            progressBox
        );
        detailsBox.setPrefWidth(600);
        
        VBox statsBox = new VBox(10, 
            new Label("Statistics"), 
            statsGrid
        );
        
        infoGridLayout.getChildren().addAll(detailsBox, statsBox);
        
        // Chapters header
        Label chaptersHeader = new Label("Chapters");
        chaptersHeader.setStyle("-fx-font-size: 20px; -fx-font-weight: bold;");
        
        VBox chaptersBox = new VBox(10, 
            chaptersHeader,
            searchBox, 
            chaptersTabPane
        );
        chaptersBox.setPadding(new Insets(20, 0, 0, 0));
        
        // Combine all sections into the main layout
        VBox leftPanel = new VBox(20, coverImageView);
        leftPanel.setAlignment(Pos.TOP_CENTER);
        
        VBox rightPanel = new VBox(20,
            topInfoLayout,
            infoGridLayout,
            chaptersBox
        );
        
        HBox mainLayout = new HBox(30, leftPanel, rightPanel);
        mainLayout.setPadding(new Insets(20));
        
        // Add to the BorderPane
        setCenter(new ScrollPane(mainLayout));
        
        // Initial sort order is newest first
        sortChapters("Newest First");
    }

    // Create the chapter grid view
    private GridPane createChapterGrid() {
        GridPane grid = new GridPane();
        grid.setHgap(15);
        grid.setVgap(15);
        grid.setPadding(new Insets(15));
        return grid;
    }
    
    // Create the volume view with accordion
    private ScrollPane createVolumeView() {
        Accordion accordion = new Accordion();
        accordion.setPadding(new Insets(15));
        ScrollPane scrollPane = new ScrollPane(accordion);
        scrollPane.setFitToWidth(true);
        return scrollPane;
    }
    
    // Method to update the chapter grid
    private void updateChapterGrid(GridPane grid, List<Chapter> chapters) {
        grid.getChildren().clear();
        int col = 0;
        int row = 0;
        int maxCols = 5;

        for (Chapter chapter : chapters) {
            VBox chapterBox = new VBox(5);
            chapterBox.setPadding(new Insets(10));
            chapterBox.setAlignment(Pos.CENTER);
            chapterBox.setStyle(
                "-fx-background-color: white; " +
                "-fx-border-color: #dee2e6; " +
                "-fx-border-radius: 8; " +
                "-fx-background-radius: 8; " +
                "-fx-effect: dropshadow(gaussian, rgba(0,0,0,0.1), 4, 0, 0, 2);"
            );

            Label chapterNumLabel = new Label(String.format("Chapter %.1f", chapter.getNumber()));
            chapterNumLabel.setStyle("-fx-font-weight: bold;");

            Label volumeLabel = new Label(chapter.getVolume() != null ? "Vol. " + chapter.getVolume() : "");
            volumeLabel.setStyle("-fx-font-size: 12px; -fx-text-fill: #666;");

            // Read status indicator
            Circle readStatusIndicator = new Circle(5);
            readStatusIndicator.setFill(Color.LIGHTGRAY);
            
            boolean isRead = false;
            if (isRead) {
                readStatusIndicator.setFill(Color.GREEN);  // Read
            }

            HBox statusBox = new HBox(5, readStatusIndicator, chapterNumLabel);
            statusBox.setAlignment(Pos.CENTER);

            Button readButton = new Button("Read");
            readButton.setStyle(
                "-fx-background-color: #007bff; " +
                "-fx-text-fill: white;"
            );
            
            readButton.setOnAction(e -> {
                if (onChapterSelectedCallback != null) {
                    onChapterSelectedCallback.accept(chapter);
                }
            });

            chapterBox.getChildren().addAll(statusBox, volumeLabel, readButton);
            grid.add(chapterBox, col, row);

            col++;
            if (col >= maxCols) {
                col = 0;
                row++;
            }
        }
    }
    
    // Method for updating volume-based chapter grid (smaller chapter cards)
    private void updateVolumeChapterGridLayout(GridPane grid, List<Chapter> chapters) {
        grid.getChildren().clear();
        int col = 0;
        int row = 0;
        int maxCols = 5;
        
        for (Chapter chapter : chapters) {
            Button chapterBtn = new Button("Chapter " + chapter.getNumber());
            chapterBtn.setMaxWidth(Double.MAX_VALUE);
            
            chapterBtn.setOnAction(e -> {
                if (onChapterSelectedCallback != null) {
                    onChapterSelectedCallback.accept(chapter);
                }
            });
            
            // Add tooltip with chapter title
            Tooltip tooltip = new Tooltip(chapter.getTitle());
            Tooltip.install(chapterBtn, tooltip);
            
            // Add to grid
            grid.add(chapterBtn, col, row);
            GridPane.setHgrow(chapterBtn, Priority.ALWAYS);
            GridPane.setFillWidth(chapterBtn, true);
            
            col++;
            if (col >= maxCols) {
                col = 0;
                row++;
            }
        }
    }

    // Method to update the volume view with accordion panels
    private void updateVolumeView(Accordion accordion, List<Chapter> chapters) {
        accordion.getPanes().clear();
        
        // Group chapters by volume
        Map<String, List<Chapter>> volumeChapters = chapters.stream()
            .collect(Collectors.groupingBy(
                chapter -> chapter.getVolume() != null ? chapter.getVolume() : "No Volume")
            );

        // Create a pane for each volume with its chapters
        volumeChapters.forEach((volume, volumeChapterList) -> {
            String title = volume.equals("No Volume") ? "Chapters (No Volume)" : "Volume " + volume;
            
            // Create grid for the chapters in this volume
            GridPane chapterGrid = new GridPane();
            chapterGrid.setHgap(10);
            chapterGrid.setVgap(10);
            chapterGrid.setPadding(new Insets(15));
            
            updateVolumeChapterGridLayout(chapterGrid, volumeChapterList);
            
            // Create titled pane for this volume
            TitledPane volumePane = new TitledPane(title + " (" + volumeChapterList.size() + " chapters)", 
                new ScrollPane(chapterGrid));

            // Add volume cover if available (placeholder)
            accordion.getPanes().add(volumePane);
        });
    }
    
    // Update the chapter table with the current page of chapters
    private void updateChapterTable() {
        int fromIndex = currentChapterPage * CHAPTERS_PER_PAGE;
        int toIndex = Math.min(fromIndex + CHAPTERS_PER_PAGE, sortedChapters.size());
        
        if (fromIndex >= sortedChapters.size()) {
            return;
        }
        
        // Update pagination
        int pageCount = (int) Math.ceil((double) sortedChapters.size() / CHAPTERS_PER_PAGE);
        if (pageCount == 0) {
            pageCount = 1; // At least one page even if empty
        }
        chapterPagination.setPageCount(pageCount);
        
        // Update the current page if it's out of bounds
        if (currentChapterPage >= pageCount) {
            currentChapterPage = pageCount - 1;
            chapterPagination.setCurrentPageIndex(currentChapterPage);
        }
    }
    
    // Filter chapters by search text
    private void filterChapters(String searchText) {
        String lowerCaseSearch = searchText.toLowerCase();
        
        Predicate<Chapter> textPredicate = chapter -> {
            if (searchText == null || searchText.isEmpty()) {
                return true;
            }
            
            return chapter.getTitle().toLowerCase().contains(lowerCaseSearch) ||
                   String.valueOf(chapter.getNumber()).contains(lowerCaseSearch);
        };
        
        // Combine with volume filter
        String volumeFilter = filterComboBox.getValue();
        Predicate<Chapter> volumePredicate = getVolumeFilterPredicate(volumeFilter);
        
        filteredChapters.setPredicate(volumePredicate.and(textPredicate));
        updateChapterTable();
    }
    
    // Filter chapters by volume
    private void filterChaptersByVolume(String volumeFilter) {
        Predicate<Chapter> volumePredicate = getVolumeFilterPredicate(volumeFilter);
        
        // Combine with text filter
        String searchText = chapterSearchField.getText();
        String lowerCaseSearch = searchText.toLowerCase();
        
        Predicate<Chapter> textPredicate = chapter -> {
            if (searchText == null || searchText.isEmpty()) {
                return true;
            }
            
            return chapter.getTitle().toLowerCase().contains(lowerCaseSearch) ||
                   String.valueOf(chapter.getNumber()).contains(lowerCaseSearch);
        };
        
        filteredChapters.setPredicate(volumePredicate.and(textPredicate));
        updateChapterTable();
    }
    
    // Get predicate for volume filtering
    private Predicate<Chapter> getVolumeFilterPredicate(String volumeFilter) {
        if (volumeFilter == null || volumeFilter.isEmpty() || volumeFilter.equals("All")) {
            return chapter -> true;
        } else if (volumeFilter.equals("No Volume")) {
            return chapter -> chapter.getVolume() == null || chapter.getVolume().isEmpty();
        } else {
            // Extract volume number, e.g. "Volume 1" -> "1"
            String volumeNumber = volumeFilter.replace("Volume ", "").trim();
            return chapter -> chapter.getVolume() != null && chapter.getVolume().equals(volumeNumber);
        }
    }
    
    // Sort chapters based on selected option
    private void sortChapters(String sortOption) {
        if (sortOption.equals("Newest First")) {
            sortedChapters.setComparator(Comparator.comparing(Chapter::getNumber).reversed());
        } else if (sortOption.equals("Oldest First")) {
            sortedChapters.setComparator(Comparator.comparing(Chapter::getNumber));
        } else if (sortOption.equals("By Volume")) {
            sortedChapters.setComparator((c1, c2) -> {
                String vol1 = c1.getVolume() == null ? "" : c1.getVolume();
                String vol2 = c2.getVolume() == null ? "" : c2.getVolume();
                
                // Try numeric comparison for volumes
                try {
                    if (!vol1.isEmpty() && !vol2.isEmpty()) {
                        int v1 = Integer.parseInt(vol1);
                        int v2 = Integer.parseInt(vol2);
                        int volCompare = Integer.compare(v1, v2);
                        
                        if (volCompare != 0) {
                            return volCompare;
                        }
                    }
                } catch (NumberFormatException e) {
                    // If parsing fails, use string comparison
                }
                
                int volumeCompare = vol1.compareTo(vol2);
                if (volumeCompare != 0) {
                    return volumeCompare;
                }
                
                // If volumes are the same, sort by chapter number
                return Double.compare(c1.getNumber(), c2.getNumber());
            });
        }
        
        // Also update the grid and volume views
        Tab gridTabForSort = chaptersTabPane.getTabs().get(1);
        updateChapterGrid((GridPane) ((ScrollPane) gridTabForSort.getContent()).getContent(), sortedChapters);
        
        Tab volumeTabForSort = chaptersTabPane.getTabs().get(2);
        updateVolumeView((Accordion) ((ScrollPane) volumeTabForSort.getContent()).getContent(), sortedChapters);
    }

    // Load chapters for a manga
    private void loadChapters(String mangaId) {
        chapters.clear();
        
        // Update UI to show loading state
        Label emptyLabel = new Label("");
        chaptersTable.setPlaceholder(emptyLabel);
        
        ProgressIndicator progressIndicator = new ProgressIndicator();
        progressIndicator.setPrefSize(50, 50);
        
        Label loadingLabel = new Label("Loading chapters...");
        loadingLabel.setStyle("-fx-font-size: 16px;");
        
        VBox loadingBox = new VBox(15, progressIndicator, loadingLabel);
        loadingBox.setAlignment(Pos.CENTER);
        
        chaptersTable.setPlaceholder(loadingBox);

        // Clear other views as well
        Tab gridTabForLoading = chaptersTabPane.getTabs().get(1);
        Label loadingGridLabel = new Label("Loading chapters...");
        loadingGridLabel.setStyle("-fx-font-size: 16px;");
        ((ScrollPane) gridTabForLoading.getContent()).setContent(new StackPane(loadingGridLabel));

        Tab volumeTabForLoading = chaptersTabPane.getTabs().get(2);
        Label loadingVolumeLabel = new Label("Loading chapters...");
        loadingVolumeLabel.setStyle("-fx-font-size: 16px;");
        ((ScrollPane) volumeTabForLoading.getContent()).setContent(new StackPane(loadingVolumeLabel));

        // Fetch chapters in a background thread
        new Thread(() -> {
            List<Chapter> fetchedChapters = mangaService.getChapters(mangaId);
            Platform.runLater(() -> {
                if (fetchedChapters != null && !fetchedChapters.isEmpty()) {
                    chapters.addAll(fetchedChapters);
                    
                    // Update stats
                    statsLabels.get("Chapter Count").setText(String.valueOf(fetchedChapters.size()));
                    
                    // Update the number of chapters label
                    totalChaptersLabel.setText("Total: " + fetchedChapters.size() + " chapters");
                    
                    // Set initial sort order to newest first
                    sortedChapters.setComparator(Comparator.comparing(Chapter::getNumber).reversed());
                    
                    // Update volume filter options
                    filterComboBox.getItems().clear();
                    filterComboBox.getItems().add("All");
                    filterComboBox.getItems().add("No Volume");
                    
                    fetchedChapters.stream()
                        .map(Chapter::getVolume)
                        .filter(v -> v != null && !v.isEmpty())
                        .distinct()
                        .forEach(volume -> filterComboBox.getItems().add("Volume " + volume));
                    
                    filterComboBox.setValue("All");
                    
                    // Update the chapter grid
                    Tab gridTabForFetch = chaptersTabPane.getTabs().get(1);
                    updateChapterGrid((GridPane) ((ScrollPane) gridTabForFetch.getContent()).getContent(), fetchedChapters);
                    
                    // Update the volume view
                    Tab volumeTabForFetch = chaptersTabPane.getTabs().get(2);
                    updateVolumeView((Accordion) ((ScrollPane) volumeTabForFetch.getContent()).getContent(), fetchedChapters);
                    
                    int chaptersRead = 0;
                    double progress = chapters.isEmpty() ? 0 : (double) chaptersRead / chapters.size();
                    readProgressBar.setProgress(progress);
                    readProgressLabel.setText(chaptersRead + " / " + chapters.size() + " chapters read");
                    
                } else {
                    // No chapters found
                    totalChaptersLabel.setText("Total: 0 chapters");
                    statsLabels.get("Chapter Count").setText("0");
                    
                    // Update reading progress
                    readProgressBar.setProgress(0);
                    readProgressLabel.setText("0 / 0 chapters read");
                    
                    // Update the tab views
                    Tab gridTabForEmpty = chaptersTabPane.getTabs().get(1);
                    Label noChaptersGridLabel = new Label("No chapters found.");
                    noChaptersGridLabel.setStyle("-fx-font-size: 16px; -fx-text-fill: #666;");
                    ((ScrollPane) gridTabForEmpty.getContent()).setContent(new StackPane(noChaptersGridLabel));
                    
                    Tab volumeTabForEmpty = chaptersTabPane.getTabs().get(2);
                    Label noChaptersVolumeLabel = new Label("No chapters found.");
                    noChaptersVolumeLabel.setStyle("-fx-font-size: 16px; -fx-text-fill: #666;");
                    ((ScrollPane) volumeTabForEmpty.getContent()).setContent(new StackPane(noChaptersVolumeLabel));
                }
            });
        }).start();
    }

    // Load image with error handling and fallback
    private void loadCoverImage(Manga manga) {
        String placeholderUrl = "https://via.placeholder.com/250x350/f8f9fa/6c757d?text=No+Cover";
        
        if (manga.getCoverUrl() == null || manga.getCoverUrl().isEmpty()) {
            coverImageView.setImage(new Image(placeholderUrl, true));
            return;
        }
        
        try {
            // Try to load the cover image
            Image image = new Image(manga.getCoverUrl(), true);
            coverImageView.setImage(image);
            
            // Add loading error handler
            image.errorProperty().addListener((obs, oldError, newError) -> {
                if (newError) {
                    System.err.println("Error loading cover image: " + manga.getCoverUrl());
                    coverImageView.setImage(new Image(placeholderUrl, true));
                }
            });
        } catch (Exception e) {
            System.err.println("Error loading cover image: " + e.getMessage());
            coverImageView.setImage(new Image(placeholderUrl, true));
        }
    }

    // Display manga details
    public void displayManga(Manga manga) {
        if (manga == null) {
            clear();
            return;
        }
        this.currentManga = manga;

        // Set manga information
        titleLabel.setText(manga.getTitle());
        authorLabel.setText("Author: " + (manga.getAuthor() != null ? manga.getAuthor() : "Unknown"));
        artistLabel.setText("Artist: " + (manga.getArtist() != null ? manga.getArtist() : "Unknown"));
        statusLabel.setText(manga.getStatus() != null ? manga.getStatus() : "Unknown");
        languageLabel.setText(manga.getLanguage() != null ? manga.getLanguage() : "Unknown");

        if (manga.getLastUpdated() != null) {
            lastUpdatedLabel.setText(
                    "Last updated: " + manga.getLastUpdated().format(DateTimeFormatter.ofPattern("MMMM d, yyyy")));
        } else {
            lastUpdatedLabel.setText("");
        }

        // Set description
        descriptionArea.setText(manga.getDescription());

        // Load cover image with enhanced error handling
        loadCoverImage(manga);

        // Set genres with improved styling
        genresPane.getChildren().clear();
        if (manga.getGenres() != null) {
            for (String genre : manga.getGenres()) {
                Label genreLabel = new Label(genre);
                genreLabel.setStyle(
                        "-fx-background-color: #e7f3ff; " +
                                "-fx-padding: 6 12; " +
                                "-fx-background-radius: 18; " +
                                "-fx-font-size: 12px; " +
                                "-fx-text-fill: #0066cc; " +
                                "-fx-border-color: #b3d9ff; " +
                                "-fx-border-width: 1; " +
                                "-fx-border-radius: 18;");

                // Hover effect
                genreLabel.setOnMouseEntered(e -> genreLabel.setStyle(
                        "-fx-background-color: #cce5ff; " +
                                "-fx-padding: 6 12; " +
                                "-fx-background-radius: 18; " +
                                "-fx-font-size: 12px; " +
                                "-fx-text-fill: #004085; " +
                                "-fx-border-color: #b8daff; " +
                                "-fx-border-width: 1; " +
                                "-fx-border-radius: 18;"));

                genreLabel.setOnMouseExited(e -> genreLabel.setStyle(
                        "-fx-background-color: #e7f3ff; " +
                                "-fx-padding: 6 12; " +
                                "-fx-background-radius: 18; " +
                                "-fx-font-size: 12px; " +
                                "-fx-text-fill: #0066cc; " +
                                "-fx-border-color: #b3d9ff; " +
                                "-fx-border-width: 1; " +
                                "-fx-border-radius: 18;"));

                genresPane.getChildren().add(genreLabel);
            }
        }

        // Update the volume filter dropdown based on manga's volumes
        updateVolumeFilter(manga);

        // Update stats display (placeholder data - in a real app, this would come from
        // the API)
        statsLabels.get("Rating").setText("4.8/5");
        statsLabels.get("Users").setText("12,345");
        statsLabels.get("Follows").setText("5,678");
        statsLabels.get("Popularity").setText("#123");
        statsLabels.get("Release Year").setText("2020");
        statsLabels.get("Chapter Count").setText("Loading...");

        // Load chapters
        loadChapters(manga.getId());

        // Button actions
        readButton.setOnAction(e -> {
            if (!chapters.isEmpty()) {
                // Assume first chapter is what we want to read
                Chapter firstChapter = chapters.stream()
                        .min(Comparator.comparing(Chapter::getNumber))
                        .orElse(chapters.get(0));

                if (onChapterSelectedCallback != null) {
                    onChapterSelectedCallback.accept(firstChapter);
                }
            }
        });
    }

    private void updateVolumeFilter(Manga manga) {
        filterComboBox.getItems().clear();
        filterComboBox.getItems().add("All");
        filterComboBox.setValue("All");
    }

    // Clear all manga information
    private void clear() {
        titleLabel.setText("");
        authorLabel.setText("");
        artistLabel.setText("");
        statusLabel.setText("");
        languageLabel.setText("");
        lastUpdatedLabel.setText("");
        descriptionArea.setText("");
        coverImageView.setImage(null);
        genresPane.getChildren().clear();
        chapters.clear();

        // Clear stats
        for (Label label : statsLabels.values()) {
            label.setText("--");
        }

        // Clear reading progress
        readProgressBar.setProgress(0);
        readProgressLabel.setText("0 / 0 chapters read");

        Label emptyLabel = new Label("");
        chaptersTable.setPlaceholder(emptyLabel);
    }

    public Button getReadButton() {
        return readButton;
    }

    public Button getDownloadButton() {
        return downloadButton;
    }

    public Button getAddToLibraryButton() {
        return addToLibraryButton;
    }

    public Button getRefreshButton() {
        return refreshButton;
    }
}
